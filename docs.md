FORMAT: 1A

# Plaits.js

# Group Introduction
Plaits is a form creation, validation and rendering library for Node.js.

It supports both synchronous and asynchronous validation (via [Promises](https://github.com/petkaantonov/bluebird/)), and comes with many built-in validators, many of which are provided
by the excellent [validator.js library](https://github.com/chriso/validator.js).

It is intended for use with [Express](http://expressjs.com/), but can be used with other libraries and frameworks too.

Plaits is inspired by the form validation features found in frameworks such as [.NET MVC](http://www.asp.net/mvc/mvc4),
and thanks goes to the great work done on the [Bookshelf ORM](https://github.com/tgriesser/bookshelf) for additional inspiration and helping with some underlying code principles.

The source is available on [GitHub](https://github.com/Persata/plaits), and it comes with a large suite of [unit tests](https://travis-ci.org/Persata/plaits).

# Group Latest Release - 0.1.0
Build Status - [![Build Status](https://travis-ci.org/Persata/plaits.svg)](https://travis-ci.org/Persata/plaits)

Dependencies - [![Dependency Status](https://gemnasium.com/Persata/plaits.svg)](https://gemnasium.com/Persata/plaits)

Code Coverage - [![Coverage Status](https://img.shields.io/coveralls/Persata/plaits.svg)](https://coveralls.io/r/Persata/plaits?branch=master)

Please feel free to report bugs and suggest features you'd like to see on the [Plaits GitHub Issues Page](https://github.com/Persata/plaits/issues),
or send tweets to [@persata](https://twitter.com/persata).

[Changelog](#changelog)

# Group Form Models

Plaits models are simply [Backbone](http://backbonejs.org/) models with different functionality.

A model **must** be given a name, and a list of fields. It also takes an optional list of validators [(examples later)](#provided-validators).

A basic model example:

```
// Require Plaits
var Plaits = require('plaits');

// Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    // Form Name
    name: 'register_form',
    // Field List
    fields: [
      'username',
      'email_address',
      'password',
      'confirm_password'
    ],
    // Validators
    validators: {
      username: [
        Plaits.Validators.required(),
        Plaits.Validators.alphanumeric()
      ],
      email_address: [
        Plaits.Validators.required(),
        Plaits.Validators.email()
      ],
      password: [
        Plaits.Validators.required(),
        Plaits.Validators.minLength(8)
      ],
      confirm_password [
        Plaits.Validators.matchProperty('password')
      ]
    }
  }
);

// Export Form
module.exports = RegisterForm;
```

## Model Field Labels [/]

Models can also take a labels object as part of their declaration:
```
// Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    ...
    labels: {
      'username': 'Your Chosen Username'
    }
    ...
  }
);
```

If a label is not provided, it will be auto generated by [Node Inflection's](https://github.com/dreamerslab/node.inflection) titleize function, for example:
```
email_address => 'Email Address'
confirm_password => 'Confirm Password'
```

## Model Defaults [/]

You can specify the defaults for model values using the ```defaults``` key:

```
// Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    ...
    defaults: {
      'email_address': 'email@example.com'
    }
    ...
  }
);
```

## Model Instantiation [/]

To instantiate a form model, simply require it (if necessary) & use ```new```:
```
// Require
var RegisterForm = require('../forms/register');

// New Register Form
var registerForm = new RegisterForm();
```

# Group Model Functions

# Group Provided Validators

Plaits comes with a large set of built in validators which should be able to handle many of your use cases.
Many of the validators are backed by the [validator.js library](https://github.com/chriso/validator.js).

Many will take certain parameters to define their behaviour, for example ```minLength``` will take a parameter to define
what the minimum length should be.

## Custom Error Messages [/]

All built in validators take an optional custom error message if you wish to override the default error message.

You can use the string ```{{label}}``` in your custom error messages to have the label for the field automatically inserted,
for example the string '{{label}} must be a minimum of 10 characters' could produce 'Your password must be a minimum of 10 characters'.

There are also other strings you can use depending on the validator, such as ```{{version}}``` for IP Address, ```{{minLength}}``` for minimum length etc. Each is described below.

## Required [/]
Whether this field is required.

In most cases, this will check whether the value is null or not - null values are considered invalid.

When generating labels using the Html helpers and templates, the label text will be appended with an asterisk.
```
required(customErrorMessage)
```

## Email [/]
Checks if the provided value is an email address.
```
email(customErrorMessage)
```

## Minimum Length [/]
Checks that the value matches or exceeds the minimum length provided.
```
minLength(minLength, customErrorMessage)
```

## Maximum Length [/]
Checks that the value matches or is less than the maximum length provided.
```
maxLength(maxLength, customErrorMessage)
```

## Length [/]
This validator can be used to ensure an exact, minimum, or a range length of characters.

Ensure that if you are passing lengths that they are ints and not strings, so 6 instead of '6'.

##### Arguments

It takes between 1 and 3 arguments, as follows:

  - 1 Argument
      - An exact length for the string
  - 2 Arguments
      - Argument 1: A minimum OR exact length for the string
      - Argument 2: A maximum length for the string OR a custom error message
  - 3 Arguments
      - Argument 1: A minimum length for the string
      - Argument 2: A maximum length for the string
      - Argument 3: A custom error message

```
length(args...)
```
## Numeric [/]
Ensures the value provided is a numeric value.
```
numeric(customErrorMessage)
```

## Alpha [/]
Ensures the value provided only contains letters.
```
alpha(customErrorMessage)
```

## Alphanumeric [/]
Ensures the value provided only contains letters and numbers.
```
alphanumeric(customErrorMessage)
```

## Url [/]
This validator ensures that the value provided to the model is a valid URL.

##### Arguments

It takes between 0 and 2 arguments, as follows:

  - 0 Arguments:
      - Default options from below, default error message returned.
  - 1 Argument, either:
      - An object specifying the options to use for validation (see below), or
      - A custom error message
  - 2 Arguments
      - Argument 1: An object specifying the options to use for validation (see below)
      - Argument 2: A custom error message

##### Declaration

```
url(args...)
```

##### Default Validation Options
```
{
  protocols: ['http','https','ftp'],
  require_tld: true,
  require_protocol: false,
  allow_underscores: false,
  host_whitelist: false,
  host_blacklist: false
}
```

## IP Address [/]
This validator ensures that the value provided to the model is a valid IP address. It can be used to validate version 4 or version 6 addresses, or can be version agnostic.

##### Arguments

It takes between 0 and 2 arguments, as follows:

  - 0 Arguments:
      - IP Address matching either version 4 or version 6, default error message returned.
  - 1 Argument, either:
      - An int (not a string!) that describes the version of IP address (4 or 6), or,
      - A custom error message
  - 2 Arguments
      - Argument 1: An int (not a string!) that describes the version of IP address (4 or 6)
      - Argument 2: A custom error message

```
ipAddress(args...)
```

## Credit Card [/]
Ensures the value provided is a valid credit card number.
```
creditCard(customErrorMessage)
```

## Equals [/]
When provided with an ```equalValue``` parameter, this will make sure the value provided to the form equals the ```equalValue``` provided.
```
equals(equalValue, customErrorMessage)
```

## One Of [/]
This validator should be passed an array of acceptable values, and if the value provided to the form for validation is one of those, it will pass validation.
```
oneOf(allowedValues, customErrorMessage)
```

## Contains [/]
This validator should be passed a string as the first parameter.
If the value provided to the form for validation contains this value as a substring, it will pass validation.
```
contains(containsValue, customErrorMessage)
```

## Matches [/]
This validator should be passed a regex as the first parameter.
If the value provided to the form for validation matches this regex, it will pass validation.
```
matches(regexValue, customErrorMessage)
```

## Date [/]
This validator will loosely check that the provided value for validation is a date.
It can be of any format, even a Unix timestamp.
```
date(customErrorMessage)
```

## Date with Specific Format [/]
This validator will check that the value provided to the form for validation is a valid date, and is in the format specified.

It should be provided a date format string as an argument.

This validator is backended by the [moment.js library](https://github.com/moment/moment/).

When specifying a custom error message, you may use ```{{dateFormat}}``` to have the specified format injected into your custom error message.
```
dateForm(dateFormat, customErrorMessage)
```

## Match Another Property / Field [/]
This validator takes a property key as the first parameter.

When validation runs, it will check that the value provided to the form for validation is the same as the value of the given property.

This is usually used for comparing password & confirm password fields [(see the example above)](#form-models).
```
matchProperty(propertyKey, customErrorMessage)
```

## Int [/]
This validator will check that the value provided to the form is an integer.
```
int(customErrorMessage)
```

## Float [/]
This validator will check that the value provided to the form is floating point number.
```
float(customErrorMessage)
```

# Group Custom Validators

Plaits provides the ability to define custom validation functions for your form models.

The returned result of the custom validation function will be cast to a promise,
so the validation function can be synchronous or asynchronous depending on the requirements of the validation.

If the value provided is valid, then the overall function should return 'true',
however if the value is invalid, a string should be returned explaining why the field is invalid.

Asynchronous use cases would be such things as checking a database to ensure a unique email address or username.

## Example [/]

Custom validation functions should be defined as such:

```
/**
 * Define Your Unique Email Validator
 * @param fieldValue      - The value of the field
 * @param fieldLabel      - The label of the field
 * @param formModel       - The current instance of the form model this validator belongs to
 * @param additionalVars  - Additional vars passed to the validate() function (explained later)
 */
var uniqueEmailValidator = function(fieldValue, fieldLabel, formModel, additionalVars) {
  // Table
  var userTable = knexInstance('users');
  // Query
  return userTable.select('email').where('email', '=', fieldValue).then(function(result) {
      // Result Count
      if (result.length > 0) {
          // Return An Error
          return 'That email address is already in use!';
      } else {
          // Return True (Valid)
          return true;
      }
  });
};

// Add to Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    ...
    validators: {
      email_address: uniqueEmailValidator
    }
    ...
  }
);
```

# Group Form Request Parsing

If you are using the [Express](http://expressjs.com/) framework, you can have the module parse requests made to your routes.

This will analyse your GET and POST parameters, and assign the values to the form as they are found.

Values should be passed as ```(form name)_(field name)```, for example ```register_form_email_address```, ```register_form_confirm_password``` and so on.

## Example [/]

```
// Register Form
var RegisterForm = require('../forms/register');

// Test Route - POST
// Synchronous Parsing (Most common)
router.post('/test', function(req, res) {
    // New Form
    var registerForm = new RegisterForm();
    // Parse Request
    registerForm.parseRequestSync(req);
});

// Test Route - POST
// Asynchronous Parsing. Useful if you are using any related events that are also asynchronous.
// Unlikely but doesn't hurt to provide the option.
router.post('/test', function(req, res) {
    // New Form
    var registerForm = new RegisterForm();
    // Parse Request, Promise Based
    registerForm.parseRequest(req).then(function(formModel) {
      // ...
    });
});

```

# Group Form Validation

The main use of Plaits is to validate the data passed to the model and return feedback based on the validation result.

Validation can be done synchronously or asynchronously depending on the requirements of the form - if using all synchronous validators, then you can validate synchronously
for simpler flow control. If there is a validator that needs to be asynchronous (such as checking a web service or querying a database), then you can validate asynchronously
using Promises.

All current stock validators are synchronous, with the exception of the undocumented and yet unfinished File validators (see [coming soon](#coming-soon)).

## Validation [/]

##### Asynchronous Validation

To validate a model asynchronously, use the ```validate()``` method, which returns a Promise, eventually being fulfilled with the result of the validation.

**Please** note that the Promise is only rejected when something goes wrong with the validation - database connection timeout, exceptions etc.
If the model is invalid (i.e. the end result is false), the promise is **still** fulfilled, with a false value.
For a great explanation, see [this cartoon](http://andyshora.com/promises-angularjs-explained-as-cartoon.html).

```
// Validate
registerForm.validate().then(function (result) {
  // ...
});
```

##### Synchronous Validation

To validate a model asynchronously, use the ```validateSync()``` method, which returns the result of the validation:

```
// Validate
var result = registerForm.validateSync();
```

## Passing Objects to Validators [/]

It is often the case that if you're using a custom validator, you want to pass extra objects or information into the validation function (current user account etc).

This is possible with the ```additionalVars``` parameter on both the ```validate()``` and ```validateSync()``` methods, which will then pass the objects into the custom validation function:

##### Call Validate

```
// Current User
var currentUser = req.user;
// Validate With Additional Vars
var result = registerForm.validateSync(currentUser);
```

##### Inside The Function

```
// Custom Validator Function
var differentPassword = function(fieldValue, fieldLabel, formModel, currentUser) {
  // Do Things With 'currentUser'
};
```

## Errors [/]

Validation would be useless if it were not able to display useful feedback to the user. When a field fails validation, the error is added to the internal ```_errors``` object.

You can get errors from the model with the following functions:

### getErrors [/]

Returns the errors for all fields, or if passed a 'field' parameter, returns errors for only that field.

If there are no errors, returns an empty object.

```
model.getErrors([field])
```

### getFirstError [/]

Returns the first error for the specified field.

If there are no errors for that field, returns an empty string.

```
model.getFirstError(field)
```

### Errors Object [/]

The errors object is a key:array object that contains an entry for each field that has validation errors, for example:

```
{
  'username': [
    'Username must be at least 8 characters long.',
    'Username must consist of only letters and numbers.'
  ],
  'password': [
    'Password is a required field.'
  ]
}
```

# Group Events

Plaits models come with custom events that allow you to hook in and modify model behaviour or attributes when triggered.

## Backbone Events [/]

Since Plaits models are essentially glorified [Backbone](http://backbonejs.org/) models, you have access to all the underlying event functionality
that Backbone provides. See the Backbone documentation for each of:

  - [on](http://backbonejs.org/#Events-on)
  - [off](http://backbonejs.org/#Events-off)
  - [trigger](http://backbonejs.org/#Events-trigger)
  - [once](http://backbonejs.org/#Events-once)
  - [listenTo](http://backbonejs.org/#Events-listenTo)
  - [stopListening](http://backbonejs.org/#Events-stopListening)
  - [listenToOnce](http://backbonejs.org/#Events-listenToOnce)


## Plaits Specific Events [/]

Events use [trigger-then](https://github.com/bookshelf/trigger-then), allowing for asynchronous behaviour in your event listeners if necessary.
Ensure however, that if you are using asynchronous events that you use the asynchronous versions of ```parseRequest``` and ```validate```.

Specify the events using ```on()``` in your initialize method like so:

```
// Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    ...
    initialize: function () {
      this.on('beforeParseRequest', function (model, request) {
        ...
      });
    },
    ...
  }
);
```

## beforeParseRequest [/]

This even fires before a request is parsed, allowing you to modify the request or the model.

```
  /**
   * Before Parse Event
   * @param model PlaitsModel - The form model
   * @param request Object - The express request object
   */
  this.on('beforeParseRequest', function (model, request) {
    ...
  });
```

## afterParseRequest [/]

This even fires after a request is parsed.

```
  /**
   * Before Parse Event
   * @param model PlaitsModel - The form model
   * @param request Object - The express request object
   */
  this.on('afterParseRequest', function (model, request) {
    ...
  });
```

## beforeValidate [/]

This even fires before a model is validated.

```
  /**
   * Before Validate Event
   * @param model PlaitsModel - The form model
   */
  this.on('beforeValidate', function (model) {
    ...
  });
```

## afterValidate [/]

This even fires after a model has been validated.

```
  /**
   * After Validate Event
   * @param model PlaitsModel - The form model
   * @param validationResult Boolean - Whether the model is valid or not
   * @param validationErrors Object - An object containing any validation errors
   */
  this.on('afterValidate', function (model, validationResult, validationErrors) {
    ...
  });
```

# Group Express Middleware

# Group Html Helpers

# Group Html Templates

# Group Custom Html Templates

# Group Full Example

Below is a full (although very simple) end-to-end example of creating, rendering and validating a Plaits model using Express.

## Middleware [/]

Express ```app.js```, before routes:

```
// Require Plaits
var Plaits = require('plaits');

// Plaits Middleware
app.use(Plaits.ExpressMiddleware());
```

## Model [/]

Model Declaration, living in ```forms/register.js```:

```
// Require Plaits
var Plaits = require('plaits');

// Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    // Form Name
    name: 'register_form',
    // Field List
    fields: [
      'username',
      'email_address',
      'password',
      'confirm_password'
    ],
    // Validators
    validators: {
      username: [
        Plaits.Validators.required(),
        Plaits.Validators.alphanumeric()
      ],
      email_address: [
        Plaits.Validators.required(),
        Plaits.Validators.email()
      ],
      password: [
        Plaits.Validators.required(),
        Plaits.Validators.minLength(8)
      ],
      confirm_password [
        Plaits.Validators.matchProperty('password')
      ]
    }
  }
);

// Export Form
module.exports = RegisterForm;
```

## Routes [/]

Route file, ```routes/account.js```:

```
// Require Form
var RegisterForm = require('../forms/register');

// Account Register Route - GET
router.get('/account/register', function (req, res) {
    // New Form
    var registerForm = new RegisterForm();
    // Render Template, Passing Form
    res.render('account/register', {
        registerForm: registerForm
    });
});

// Account Register Route - POST
router.post('/account/register', function (req, res) {
    // New Form
    var registerForm = new RegisterForm();
    // Parse Request & Validate
    registerForm.parseRequestSync(req).validate().then(function (result) {
        // Valid?
        if (result) {
            // Do Register / Database Stuff Here
            // ...
            // Redirect
            res.redirect('/account/register/success');
        } else {
            // Invalid, Re-Render
            res.render('account/register', {
                registerForm: registerForm
            });
        }
    }).catch(function (e) {
        // Something Went Horribly Wrong, Caught A Rejected Promise
        res.json(e);
    });
});
```

## Template [/]

Register template, ```account/register.jade```:

```
extends layout

block content
    form(method='POST')
        !=Plaits.Html.Template.text(registerForm, 'username')
        !=Plaits.Html.Template.email(registerForm, 'email')
        !=Plaits.Html.Template.password(registerForm, 'password')
        !=Plaits.Html.Template.password(registerForm, 'confirm_password')
        !=Plaits.Html.Template.submit()
```

# Group Coming Soon

Here are a few things I plan on incorporating or working on the future.

## File Validation [/]

Any good form library should be able to validate uploaded files.
I've already written a lot of this functionality (see [lib/validators/file.js](https://github.com/Persata/plaits/blob/master/lib/validators/file.js)).

Unfortunately, the implementation on which I based these used [connect-multiparty](https://github.com/andrewrk/connect-multiparty),
which is now deprecated and the use of which is being advised against (for [some good reasons](http://andrewkelley.me/post/do-not-use-bodyparser-with-express-js.html)).

I am looking into alternative implementations.

## More Validators [/]

Extra provided validators are always useful to prevent people from having to write their own, especially if tested and approved. A few that spring to mind:

  - Number Range Validator (Numbers greater than etc.)
  - Date Range Validator (Dates between X and Y, dates only before Y, etc.)

## Examples Repository [/]

A GitHub repository with some examples of using Plaits in different circumstances would be useful.

# Group Changelog

##### 0.1.0 - Initial Release
  - Initial Release