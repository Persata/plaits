FORMAT: 1A

# Plaits.js

# Group Introduction
Plaits is a form creation, validation and rendering library for Node.js.

It supports both synchronous and asynchronous validation (via [Promises](https://github.com/petkaantonov/bluebird/)), and comes with many built-in validators which are provided
by the excellent [validator.js library](https://github.com/chriso/validator.js).

It is intended for use with [Express](http://expressjs.com/), but can be used with other libraries and frameworks too.

Source is available on [GitHub](https://github.com/Persata/plaits), and comes with a large suite of [unit tests](https://travis-ci.org/Persata/plaits).

# Group Latest Release - 0.1.0
Build Status - [![Build Status](https://travis-ci.org/Persata/plaits.svg)](https://travis-ci.org/Persata/plaits)

Dependencies - [![Dependency Status](https://gemnasium.com/Persata/plaits.svg)](https://gemnasium.com/Persata/plaits)

Code Coverage - [![Coverage Status](https://img.shields.io/coveralls/Persata/plaits.svg)](https://coveralls.io/r/Persata/plaits?branch=master)

[Changelog](#changelog)

# Group Form Models

Plaits models are simply Backbone models with different functionality.

A model **must** be given a name, and a list of fields. It also takes an optional list of validators [(examples later)](#provided-validators).

A basic model example:

```
// Require Plaits
var Plaits = require('plaits');

// Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    // Form Name
    name: 'register_form',
    // Field List
    fields: [
      'username',
      'email_address',
      'password',
      'confirm_password'
    ],
    // Validators
    validators: {
      username: [
        Plaits.Validators.required(),
        Plaits.Validators.alphanumeric()
      ],
      email_address: [
        Plaits.Validators.required(),
        Plaits.Validators.email()
      ],
      password: [
        Plaits.Validators.required(),
        Plaits.Validators.minLength(8)
      ],
      confirm_password [
        Plaits.Validators.matchProperty('password')
      ]
    }
  }
);

// Export Form
module.exports = RegisterForm;
```

## Model Field Labels [/]

Models can also take a labels object as part of their declaration:
```
// Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    ...
    labels: {
      'username': 'Your Chosen Username'
    }
    ...
  }
);
```

If a label is not provided, it will be auto generated by [Node Inflection's](https://github.com/dreamerslab/node.inflection) titleize function, for example:
```
email_address => 'Email Address'
confirm_password => 'Confirm Password'
```

## Model Instantiation [/]

To instantiate a form model, simply require & use ```new```:
```
// Require
var RegisterForm = require('../forms/register');

// New Register Form
var registerForm = new RegisterForm();
```

# Group Provided Validators

Plaits comes with a large set of built in validators which should be able to handle many of your use cases.
Many of the validators are backed by the [validator.js library](https://github.com/chriso/validator.js).

Many will take certain parameters to define their behaviour, for example ```minLength``` will take a parameter to define
what the minimum length should be.

## Custom Error Messages [/]

All built in validators take an optional custom error message if you wish to override the default error message.

You can use the string ```{{label}}``` in your custom error messages to have the label for the field automatically inserted,
for example the string '{{label}} must be a minimum of 10 characters' could produce 'Your password must be a minimum of 10 characters'.

## Required [/]
```
required(customErrorMessage)
```
Whether this field is required.

In most cases, this will check whether the value is null or not - null values are considered invalid.

When generating labels using the Html helpers and templates, the label text will be appended with an asterisk.

## Email [/]
```
email(customErrorMessage)
```
Checks if the provided value is an email address.

## Minimum Length [/]
```
minLength(minLength, customErrorMessage)
```

Checks that the value matches or exceeds the minimum length provided.

## Maximum Length [/]
```
maxLength(maxLength, customErrorMessage)
```

Checks that the value matches or is less than the maximum length provided.

## Length [/]
```
length(args...)
```
## Numeric [/]
```
numeric(customErrorMessage)
```

Ensures the value provided is a numeric value.

## Alpha [/]
```
alpha(customErrorMessage)
```

Ensures the value provided only contains letters.

## Alphanumeric [/]
```
alphanumeric(customErrorMessage)
```

Ensures the value provided only contains letters and numbers.

## Url [/]
```
url(args...)
```
## IP Address [/]
```
ipAddress(args...)
```
## Credit Card [/]
```
creditCard(customErrorMessage)
```

Ensures the value provided is a valid credit card number.

## Equals [/]
```
equals(equalValue, customErrorMessage)
```

When provided with an ```equalValue``` parameter, this will make sure the value provided to the form equals the ```equalValue``` provided.

## One Of [/]
```
oneOf(allowedValues, customErrorMessage)
```

This validator should be passed an array of acceptable values, and if the value provided to the form for validation is one of those, it will pass validation.

## Contains [/]
```
contains(containsValue, customErrorMessage)
```

This validator should be passed a string as the first parameter.
If the value provided to the form for validation contains this value as a substring, it will pass validation.

## Matches [/]
```
matches(regexValue, customErrorMessage)
```

This validator should be passed a regex as the first parameter.
If the value provided to the form for validation matches this regex, it will pass validation.

## Date [/]
```
date(customErrorMessage)
```

This validator will loosely check that the provided value for validation is a date.
It can be of any format, even a Unix timestamp.

## Date with Specific Format [/]
```
dateForm(dateFormat, customErrorMessage)
```

This validator should be provided a date format string.

It will check that the value provided to the form for validation is a valid date, and is in the format specified.

This validator is backended by the [moment.js library](https://github.com/moment/moment/).

When specifying a custom error message, you may use ```{{dateFormat}}``` to have the specified format injected into your custom error message.

## Match Another Property / Field [/]
```
matchProperty(propertyKey, customErrorMessage)
```

This validator takes a property key as the first parameter.

When validation runs, it will check that the value provided to the form for validation is the same as the value of the given property.

This is usually used for comparing password & confirm password fields [(see the example above)](#form-models).

## Int [/]
```
int(customErrorMessage)
```

This validator will check that the value provided to the form is an integer.

## Float [/]
```
float(customErrorMessage)
```

This validator will check that the value provided to the form is floating point number.

# Group Custom Validators

Plaits provides the ability to define custom validation functions for your form models.

The returned result of the custom validation function will be cast to a promise,
so the validation function can be synchronous or asynchronous depending on the requirements of the validation.

If the value provided is valid, then the overall function should return 'true',
however if the value is invalid, a string should be returned explaining why the field is invalid.

Asynchronous use cases would be such things as checking a database to ensure a unique email address or username.

## Example [/]

Custom validation functions should be defined as such:

```
/**
 * Define Your Unique Email Validator
 * @param fieldValue      - The value of the field
 * @param fieldLabel      - The label of the field
 * @param formModel       - The current instance of the form model this validator belongs to
 * @param additionalVars  - Additional vars passed to the validate() function (explained later)
 */
var uniqueEmailValidator = function(fieldValue, fieldLabel, formModel, additionalVars) {
  // Table
  var userTable = knexInstance('users');
  // Query
  return userTable.select('email').where('email', '=', fieldValue).then(function(result) {
      // Result Count
      if (result.length > 0) {
          // Return An Error
          return 'That email address is already in use!';
      } else {
          // Return True (Valid)
          return true;
      }
  });
};

// Add to Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    ...
    validators: {
      email_address: uniqueEmailValidator
    }
    ...
  }
);
```

# Group Form Request Parsing

If you are using the [Express](http://expressjs.com/) framework, you can have the module parse requests made to your routes.

This will analyse your GET and POST parameters, and assign the values to the form as they are found.

Values should be passed as ```(form name)_(field name)```, for example ```register_form_email_address```, ```register_form_confirm_password``` and so on.

## Example [/]

```
// Register Form
var RegisterForm = require('../forms/register');

// Test Route - POST
// Synchronous Parsing (Most common)
router.post('/test', function(req, res) {
    // New Form
    var registerForm = new RegisterForm();
    // Parse Request
    registerForm.parseRequestSync(req);
});

// Test Route - POST
// Asynchronous Parsing. Useful if you are using any related events that are also asynchronous.
// Unlikely but doesn't hurt to provide the option.
router.post('/test', function(req, res) {
    // New Form
    var registerForm = new RegisterForm();
    // Parse Request, Promise Based
    registerForm.parseRequest(req).then(function(formModel) {
      // ...
    });
});

```

# Group Form Validation

The main intention of Plaits is to validate the data passed to the model and return feedback based on the validation result.

## Validation [/]

## Errors [/]

# Group Events

Plaits models come with custom events that allow you to hook in and modify model behaviour or attributes when triggered.

Events for asynchronous operations (e.g. parse and validate) use [trigger-then](https://github.com/bookshelf/trigger-then), allowing for asynchronous behaviour in your event listeners if necessary.
Ensure however, that if you are using asynchronous events that you use the asynchronous versions of ```parseRequest``` and ```validate```.

Specify the events using ```on()``` in your initialize method like so:

```
// Register Form Declaration
var RegisterForm = Plaits.Model.extend(
{
  ...
  initialize: function () {
    this.on('beforeParseRequest', function (model, request) {
      ...
    });
  },
  ...
}
);
```

## beforeParseRequest [/]

This even fires before a request is parsed, allowing you to modify the request or the model.

```
  /**
   * Before Parse Event
   * @param model PlaitsModel - The form model
   * @param request Object - The express request object
   */
  this.on('beforeParseRequest', function (model, request) {
    ...
  });
```

## afterParseRequest [/]

This even fires after a request is parsed.

```
  /**
   * Before Parse Event
   * @param model PlaitsModel - The form model
   * @param request Object - The express request object
   */
  this.on('afterParseRequest', function (model, request) {
    ...
  });
```

## beforeValidate [/]

This even fires before a model is validated.

```
  /**
   * Before Validate Event
   * @param model PlaitsModel - The form model
   */
  this.on('beforeValidate', function (model) {
    ...
  });
```

## afterValidate [/]

This even fires after a model has been validated.

```
  /**
   * After Validate Event
   * @param model PlaitsModel - The form model
   * @param validationResult Boolean - Whether the model is valid or not
   * @param validationErrors Object - An object containing any validation errors
   */
  this.on('afterValidate', function (model, validationResult, validationErrors) {
    ...
  });
```

# Group Express Middleware & Html Generation

## Middleware [/]

## Html Helpers [/]

## Html Templates [/]

## Custom Html Templates [/]

# Group Changelog

##### 0.1.0 - Initial Release
  - Initial Release