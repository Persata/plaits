FORMAT: 1A

# Plaits.js

# Group Introduction
Plaits is a form creation, validation and rendering library for Node.js.

It supports both synchronous and asynchronous validation (via [Promises](https://github.com/petkaantonov/bluebird/)), and comes with many built-in validators which are provided
by the excellent [validator.js library](https://github.com/chriso/validator.js).

It is intended for use with [Express](http://expressjs.com/), but can be used with other libraries and frameworks too.

Source is available on [GitHub](https://github.com/Persata/plaits), and comes with a large suite of [unit tests](https://travis-ci.org/Persata/plaits).

# Group Latest Release - 0.1.0
Build Status - [![Build Status](https://travis-ci.org/Persata/plaits.svg)](https://travis-ci.org/Persata/plaits)

Dependencies - [![Dependency Status](https://gemnasium.com/Persata/plaits.svg)](https://gemnasium.com/Persata/plaits)

Code Coverage - [![Coverage Status](https://img.shields.io/coveralls/Persata/plaits.svg)](https://coveralls.io/r/Persata/plaits?branch=master)

# Group Form Models

## Model Creation [/]

Plaits models are simply Backbone models with different functionality.

A model **must** be given a name, and a list of fields. It also takes an optional list of validators [(examples later)](#provided-validators).

A basic model example:

```
// Require Plaits
var Plaits = require('plaits');

// Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    // Form Name
    name: 'register_form',
    // Field List
    fields: [
      'username',
      'email_address',
      'password',
      'confirm_password'
    ],
    // Validators
    validators: {
      username: [
        Plaits.Validators.required(),
        Plaits.Validators.alphanumeric()
      ],
      email_address: [
        Plaits.Validators.required(),
        Plaits.Validators.email()
      ],
      password: [
        Plaits.Validators.required(),
        Plaits.Validators.minLength(8)
      ],
      confirm_password [
        Plaits.Validators.matchProperty('password')
      ]
    }
  }
);

// Export Form
module.exports = RegisterForm;
```

## Model Field Labels [/]

Models can also take a labels object as part of their declaration:
```
// Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    ...
    labels: {
      'username': 'Your Chosen Username'
    }
    ...
  }
);
```

If a label is not provided, it will be auto generated by [Node Inflection's](https://github.com/dreamerslab/node.inflection) titleize function, for example:
```
email_address => 'Email Address'
confirm_password => 'Confirm Password'
```

## Model Instantiation [/]

To instantiate a form model, simply require & use ```new```:
```
// Require
var RegisterForm = require('../forms/register');

// New Register Form
var registerForm = new RegisterForm();
```

# Group Provided Validators

Plaits comes with a large set of built in validators which should be able to handle many of your use cases.
Many of the validators are backed by the [validator.js library](https://github.com/chriso/validator.js).

Many will take certain parameters to define their behaviour, for example ```minLength``` will take a parameter to define
what the minimum length should be.

## Custom Error Messages [/]

All built in validators take an optional custom error message if you wish to override the default error message.

You can use the string ```{{label}}``` in your custom error messages to have the label for the field automatically inserted,
for example the string '{{label}} must be a minimum of 10 characters' could produce 'Your password must be a minimum of 10 characters'.

## Required [/]
```
required(customErrorMessage)
```
Whether this field is required.

In most cases, this will check whether the value is null or not - null values are considered invalid.

When generating labels using the Html helpers and templates, the label text will be appended with an asterisk.

## Email [/]
```
email(customErrorMessage)
```
Checks if the provided value is an email address.

## Minimum Length [/]
```
minLength(minLength, customErrorMessage)
```

Checks that the value matches or exceeds the minimum length provided.

## Maximum Length [/]
```
maxLength(maxLength, customErrorMessage)
```

Checks that the value matches or is less than the maximum length provided.

## Length [/]
```
length(args...)
```
## Numeric [/]
```
numeric(customErrorMessage)
```

Ensures the value provided is a numeric value.

## Alpha [/]
```
alpha(customErrorMessage)
```

Ensures the value provided only contains letters.

## Alphanumeric [/]
```
alphanumeric(customErrorMessage)
```

Ensures the value provided only contains letters and numbers.

## Url [/]
```
url(args...)
```
## IP Address [/]
```
ipAddress(args...)
```
## Credit Card [/]
```
creditCard(customErrorMessage)
```

Ensures the value provided is a valid credit card number.

## Equals [/]
```
equals(equalValue, customErrorMessage)
```

When provided with an ```equalValue``` parameter, this will make sure the value provided to the form equals the ```equalValue``` provided.

## One Of [/]
```
oneOf(allowedValues, customErrorMessage)
```

This validator should be passed an array of acceptable values, and if the value provided to the form for validation is one of those, it will pass validation.

## Contains [/]
```
contains(containsValue, customErrorMessage)
```

This validator should be passed a string as the first parameter.
If the value provided to the form for validation contains this value as a substring, it will pass validation.

## Matches [/]
```
matches(regexValue, customErrorMessage)
```

This validator should be passed a regex as the first parameter.
If the value provided to the form for validation matches this regex, it will pass validation.

## Date [/]
```
date(customErrorMessage)
```

This validator will loosely check that the provided value for validation is a date.
It can be of any format, even a Unix timestamp.

## Date with Specific Format [/]
```
dateForm(dateFormat, customErrorMessage)
```

This validator should be provided a date format string.

It will check that the value provided to the form for validation is a valid date, and is in the format specified.

This validator is backended by the [moment.js library](https://github.com/moment/moment/).

When specifying a custom error message, you may use ```{{dateFormat}}``` to have the specified format injected into your custom error message.

## Match Another Property / Field [/]
```
matchProperty(propertyKey, customErrorMessage)
```

This validator takes a property key as the first parameter.

When validation runs, it will check that the value provided to the form for validation is the same as the value of the given property.

This is usually used for comparing password & confirm password fields [(see the example above)](#form-models-model-creation).

## Int [/]
```
int(customErrorMessage)
```

This validator will check that the value provided to the form is an integer.

## Float [/]
```
float(customErrorMessage)
```

This validator will check that the value provided to the form is floating point number.

# Group Custom Validators

## Custom Functions [/]

Plaits provides the ability to define custom validation functions for your form models.

The returned result of the custom validation function will be cast to a promise,
so the validation function can be synchronous or asynchronous depending on the requirements of the validation.

If the value provided is valid, then the overall function should return 'true',
however if the value is invalid, a string should be returned explaining why the field is invalid.

Asynchronous use cases would be such things as checking a database to ensure a unique email address or username.

## Example [/]

Custom validation functions should be defined as such:

```
/**
 * Define Your Unique Email Validator
 * @param fieldValue      - The value of the field
 * @param fieldLabel      - The label of the field
 * @param formModel       - The current instance of the form model this validator belongs to
 * @param additionalVars  - Additional variables passed to the validate() function (explained later)
 */
var uniqueEmailValidator = function(fieldValue, fieldLabel, formModel, additionalVars) {
  // SQL Query
  return knexInstance('users').select('email').where('email', '=', value).then(function(result) {
      // Result Count
      if (result.length > 0) {
          // Return An Error
          return 'That email address is already in use!';
      } else {
          // Return True (Valid)
          return true;
      }
  });
};

// Add to Register Form Declaration
var RegisterForm = Plaits.Model.extend(
  {
    ...
    validators: {
      email_address: uniqueEmailValidator
    }
    ...
  }
);
```

# Group Form Request Parsing

## Intelligent Parsing [/]

If you are using the [Express](http://expressjs.com/) framework, you can have the module intelligently parse requests made to your routes.

This will analyse your GET and POST parameters, and assign the values to the form as they are found.

Values should be passed as ```(form name)_(field name)```, for example ```register_form_email_address```, ```register_form_confirm_password``` and so on.

## Example [/]

```
// Register Form
var RegisterForm = require('../forms/register');

// Test Route - POST
// Synchronous Parsing (Most common)
router.post('/test', function(req, res) {
    // New Form
    var registerForm = new RegisterForm();
    // Parse Request
    registerForm.parseRequestSync(req);
});

// Test Route - POST
// Asynchronous Parsing. Useful if you are using any related events that are also asynchronous.
// Unlikely but doesn't hurt to provide the option.
router.post('/test', function(req, res) {
    // New Form
    var registerForm = new RegisterForm();
    // Parse Request, Promise Based
    registerForm.parseRequest(req).then(function(formModel) {
      // ...
    });
});

```

# Group Form Validation

## Validation [/]

## Errors [/]

# Group Events

## beforeParseRequest [/]

## afterParseRequest [/]

## beforeValidate [/]

## afterValidate [/]

# Group Express Middleware & Html

# Group Html Helpers

# Group Html Templates
